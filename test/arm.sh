#!/bin/bash
#
# TODO: describe this file.
# make script work from an arbitrary directory (rather than being hardcoded for ${HOME}
#
# jmfoote@loyola.edu

set -e # exit if any simple command returns non-zero
set -x # this script is not polished/user-friendly, so we debug by default

BUILD_DIR=$PROJECT_DIR/build

clone() {
    # get project code (travis-ci does this automagically)
    git clone https://github.com/jfoote/exploitable -b integration
}

get_deps() {
    # install dependencies 
    sudo apt-get update
    sudo apt-get install gdb gcc python gcc-multilib g++-multilib --yes # essentials for x86
    #sudo apt-get install git vim psmisc --yes # dev tools
    sudo apt-get install qemu qemu-system python-pip --yes # arm testing 
    sudo pip install boto # accessing S3

    mkdir -p $BUILD_DIR
    pushd $BUILD_DIR
    
    # get arm cross-compile toolchain. the toolchain is stored in a private S3 
    # bucket; we use travis-ci encryption to protect the keys to the bucket
    # ref: http://about.travis-ci.org/docs/user/encryption-keys/
    set +x # don't log keys!
    : ${AWS_ACCESS_KEY_ID:?"Need to set AWS_ACCESS_KEY_ID non-empty"}
    : ${AWS_SECRET_ACCESS_KEY:?"Need to set AWS_SECRET_ACCESS_KEY non-empty"}
    set -x 
    python -c 'import boto, os; boto.connect_s3(os.environ["AWS_ACCESS_KEY_ID"], os.environ["AWS_SECRET_ACCESS_KEY"]).get_bucket("exploitable").get_key("arm-toolchain-slim.tar.bz2").get_contents_to_filename("arm-toolchain.tar.bz2")'
    tar -xjf arm-toolchain.tar.bz2 # dir is arm-2013.11
    export PATH=$PATH:${BUILD_DIR}/arm-2013.11/bin
    cpath=$BUILD_DIR/arm-2013.11/bin/arm-none-linux-gnueabi-gcc
    if [ ! -f $cpath ]; then
      echo "Compiler not found at $cpath"
    else
      echo "Compiler found at $cpath"
      file $cpath
    fi

    # get ARM test VM (see http://wiki.qemu.org/Testing#QEMU_disk_images); 
    wget http://wiki.qemu.org/download/arm-test-0.2.tar.gz # &>> log-setup.txt # arm disk image
    tar -xzf arm-test-0.2.tar.gz # dir is arm-test
    
    # get python-equipped, ARM-compatible GDB (see https://wiki.mozilla.org/Mobile/Fennec/Android/GDB)
    wget http://people.mozilla.org/~nchen/jimdb/jimdb-arm-linux_x64.tar.bz2 
    tar -xjf jimdb-arm-linux_x64.tar.bz2 # directory is jimdb-arm
    popd
}

build() {
    # build ARM test cases
    pushd ${PROJECT_DIR}/exploitable/tests
    cpath=$BUILD_DIR/arm-2013.11/bin/arm-none-linux-gnueabi-gcc
    echo "Compiler path is $cpath"
    file $cpath
    CC=$BUILD_DIR/arm-2013.11/bin/arm-none-linux-gnueabi-gcc make -f Makefile.arm
    popd
    
    # patch VM initrd to run GDB server on startup
    mkdir ${BUILD_DIR}/initrd 
    pushd ${BUILD_DIR}/initrd 
    gunzip -c ${BUILD_DIR}/arm-test/arm_root.img | cpio -i -d -H newc
    cp ${PROJECT_DIR}/exploitable/tests/bin/* ${BUILD_DIR}/initrd/root/ # all test binaries
    cp ${BUILD_DIR}/arm-2013.11/bench/gdbserver ${BUILD_DIR}/initrd/root # gdbserver 
    chmod +x ${BUILD_DIR}/initrd/root/*
    echo "
    cd /root
    /root/gdbserver --multi 10.0.2.14:1234
    " >> ${BUILD_DIR}/initrd/etc/init.d/rcS
    rm ${BUILD_DIR}/arm-test/arm_root.img
    find . | cpio -o -H newc | gzip -9 > ${BUILD_DIR}/arm-test/arm_root.img
    popd
}

run_test() {
    # start VM wait for GDB server to start
    qemu-system-arm -kernel ${BUILD_DIR}/arm-test/zImage.integrator -initrd ${BUILD_DIR}/arm-test/arm_root.img -nographic -append "console=ttyAMA0" -net nic -net user,tftp=exploitable,host=10.0.2.33 -redir tcp:1234::1234 </dev/null &> ${BUILD_DIR}/log-qemu.txt &
    until grep "Listening on port" ${BUILD_DIR}/log-qemu.txt
    do
      echo "Waiting for GDB server to start..."
      cat ${BUILD_DIR}/log-qemu.txt
      sleep 1
    done
    echo "GDB server started"
    
    # run triage; we pass a bash script that will create a per-file remote-debug GDB script to the "step-script" argument for triage.py
    pushd ${PROJECT_DIR}

    cmd="#!/bin/bash
    
    template=\"set solib-absolute-prefix nonexistantpath
    set solib-search-path ${BUILD_DIR}/arm-2013.11/arm-none-linux-gnueabi/libc/lib
    file dirname/filename
    target extended-remote localhost:1234
    set remote exec-file /root/filename
    run
    source ${PROJECT_DIR}/exploitable/exploitable.py
    exploitable -p /tmp/triage.pkl\"
    d=\`dirname \$1\`
    f=\`basename \$1\`
    sub=\${template//filename/\$f}
    sub=\${sub//dirname/\$d}
    echo \"\$sub\" > ${BUILD_DIR}/gdb_init"

    echo "$cmd" > ${BUILD_DIR}/pre_run.sh
    chmod +x ${BUILD_DIR}/pre_run.sh
    python triage.py -o ${BUILD_DIR}/result.json -vs ${BUILD_DIR}/pre_run.sh -g "${BUILD_DIR}/jimdb-arm/bin/gdb --batch -x ${BUILD_DIR}/gdb_init --args " \$sub `find exploitable/tests/bin -type f` 
    rm ${BUILD_DIR}/pre_run.sh ${BUILD_DIR}/gdb_init
    popd
    
    # kill VM
    killall qemu-system-arm

    # check results
    python -c "import json, sys; from triage import *; sys.exit(sorted(filter(lambda x: x[1], json.load(file('${BUILD_DIR}/result.json')))) != sorted(filter(lambda x: x[1], json.load(file('${PROJECT_DIR}/test/arm-expected.json')))))"
}

clean() {
    # clean up 
    pushd ${PROJECT_DIR}/exploitable/tests && make -f Makefile.arm clean && popd
    rm -rf ${BUILD_DIR}
}

echo "starting"

# Run end-to-end test, or a a list of functions if the user has specified them
if [[ -z $1 ]] ; then
  get_deps
  build
  run_test
  clean
else
  for cmd in $@
  do
    $cmd
  done
fi

echo "done!"
exit 
