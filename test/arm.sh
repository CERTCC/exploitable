#!/bin/bash
#
# TODO: describe this file.
# make script work from an arbitrary directory (rather than being hardcoded for ${HOME}
#
# jmfoote@loyola.edu

clone() {
    # get project code (travis-ci does this automagically)
    git clone https://github.com/jfoote/exploitable -b integration
}

get_deps() {
    # install dependencies 
    sudo apt-get update
    sudo apt-get install gdb gcc python --yes # essentials for x86
    sudo apt-get install git vim psmisc --yes # dev tools
    sudo apt-get install qemu python-pip --yes # arm testing 
    sudo apt-get install execstack --yes # x86 testing 
    sudo pip install boto # accessing S3
    
    # get arm cross-compile toolchain. the toolchain is stored in a private S3 
    # bucket; we use travis-ci encryption to protect the keys to the bucket
    # ref: http://about.travis-ci.org/docs/user/encryption-keys/
    python -c 'import boto, os; boto.connect_s3(os.environ["AWS_ACCESS_KEY_ID"], os.environ["AWS_SECRET_ACCESS_KEY"]).get_bucket("exploitable").get_key("arm-toolchain-slim.tar.bz2").get_contents_to_filename("arm-toolchain.tar.bz2")'
    tar -xjf arm-toolchain.tar.bz2 # dir is ~/arm-2013.11

    # get ARM test VM (see http://wiki.qemu.org/Testing#QEMU_disk_images); 
    wget http://wiki.qemu.org/download/arm-test-0.2.tar.gz # &>> log-setup.txt # arm disk image
    tar -xzf arm-test-0.2.tar.gz # dir is arm-test
    
    # get python-equipped, ARM-compatible GDB (see https://wiki.mozilla.org/Mobile/Fennec/Android/GDB)
    wget http://people.mozilla.org/~nchen/jimdb/jimdb-arm-linux_x64.tar.bz2 
    tar -xjf jimdb-arm-linux_x64.tar.bz2 # directory is jimdb-arm
}

build() {
    # build ARM test cases
    pushd ~/exploitable/exploitable/tests
    make -f Makefile.arm
    popd
    
    # patch VM initrd to run GDB server on startup
    mkdir ~/initrd 
    pushd ~/initrd && gunzip -c ~/arm-test/arm_root.img | cpio -i -d -H newc
    cp ~/exploitable/exploitable/tests/bin/* ~/initrd/root/ # all test binaries
    cp ~/arm-2013.11/bench/gdbserver ~/initrd/root # gdbserver 
    chmod +x ~/initrd/root/*
    echo "
    cd /root
    /root/gdbserver --multi 10.0.2.14:1234
    " >> ~/initrd/etc/init.d/rcS
    rm ~/arm-test/arm_root.img
    find . | cpio -o -H newc | gzip -9 > ~/arm-test/arm_root.img
    popd
}

run_test() {
    failed=1
    # start VM wait for GDB server to start
    qemu-system-arm -kernel ~/arm-test/zImage.integrator -initrd ~/arm-test/arm_root.img -nographic -append "console=ttyAMA0" -net nic -net user,tftp=exploitable,host=10.0.2.33 -redir tcp:1234::1234 </dev/null &> log-qemu.txt &
    false
    while [ $? -ne 0 ]; do
      sleep 1
      grep "Listening on port" log-qemu.txt
    done
    rm log-qemu.txt
    
    # run triage; we pass a bash script that will create a per-file remote-debug GDB script to the "step-script" argument for triage.py
    pushd exploitable
    echo '#!/bin/bash
    
    template="set solib-absolute-prefix nonexistantpath
    set solib-search-path ~/arm-2013.11/arm-none-linux-gnueabi/libc/lib
    file dirname/filename
    target extended-remote localhost:1234
    set remote exec-file /root/filename
    run
    source ~/exploitable/exploitable/exploitable.py
    exploitable -p /tmp/triage.pkl"
    d=`dirname $1`
    f=`basename $1`
    sub=${template//filename/$f}
    sub=${sub//dirname/$d}
    echo "$sub" > gdb_init
    ' > pre_run.sh
    chmod +x pre_run.sh
    python triage.py -vs ./pre_run.sh -g "${HOME}/jimdb-arm/bin/gdb --batch -x gdb_init --args " \$sub `find exploitable/tests/bin -type f` > ${HOME}/triage.txt
    rm pre_run.sh gdb_init
    popd
    
    # kill VM
    killall qemu-system-arm

    # check results
    expected='EXPLOITABLE: ReturnAv
exploitable/tests/bin/testReturnAv.test (BranchAv) (PossibleStackCorruption) (SourceAv) (AccessViolation)

EXPLOITABLE: SegFaultOnPc
exploitable/tests/bin/testStackBufferOverflow.test (PossibleStackCorruption) (AccessViolation)

EXPLOITABLE: StackCodeExection
exploitable/tests/bin/testStackCodeExecution.test (SourceAvNearNull) (AccessViolation)

EXPLOITABLE: PossibleStackCorruption
exploitable/tests/bin/testFloatingPointException.test (FloatingPointException)
exploitable/tests/bin/testAbortSignal.test (AbortSignal)
exploitable/tests/bin/testHeapError.test (AbortSignal)
exploitable/tests/bin/testPossibleStackCorruption.test (AccessViolation)
exploitable/tests/bin/testUncategorizedSignal.test (UncategorizedSignal)

EXPLOITABLE: BadInstruction
exploitable/tests/bin/testBadInstruction.test
exploitable/tests/bin/testSegFaultOnPc.test

PROBABLY_EXPLOITABLE: SegFaultOnPcNearNull
exploitable/tests/bin/testBranchAvNearNull.test (AccessViolation)
exploitable/tests/bin/testSegFaultOnPcNearNull.test (AccessViolation)

PROBABLY_NOT_EXPLOITABLE: SourceAvNearNull
exploitable/tests/bin/testSourceAv.test (AccessViolation)

PROBABLY_NOT_EXPLOITABLE: BenignSignal
exploitable/tests/bin/testBenignSignal.test' 

    result=$(tail -n `cat expected.txt | wc -l` triage.txt)
    echo result:
    echo "$result"
    echo CMP:
    if [[ ".*$result.*" =~ ".*$expected.*" ]]; then
      failed=0
    fi

}

clean() {
    # clean up 
    rm -rf ~/initrd
    rm -rf jimdb-arm
    rm jimdb-arm-linux_x64.tar.bz2
    rm -rf arm-test 
    rm arm-test-0.2.tar.gz
    pushd ~/exploitable/exploitable/tests && make -f Makefile.arm clean && popd
    rm -rf arm-2013.11
    rm arm-toolchain.tar.bz2
}

echo "starting"
failed=0

# Run end-to-end test, or a a list of functions if the user has specified them
if [[ -z $1 ]] ; then
  get_deps
  build
  run_test
  clean
else
  for cmd in $@
  do
    $cmd
  done
fi

echo "done"
exit $failed
